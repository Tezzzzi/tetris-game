<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris Bright</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  background: #000;
  color: #fff;
  font-family: "Poppins", sans-serif;
}
canvas {
  display: block;
  margin: 40px auto;
  background: #000;
}
#ui {
  position: absolute;
  top: 30px;
  right: 30px;
  background: rgba(0,0,0,0.7);
  padding: 15px 25px;
  border-radius: 10px;
}
#ui h1 {
  font-size: 20px;
  color: #fff;
  margin: 0 0 10px;
}
#ui p { margin: 4px 0; font-size: 15px; }
#bombReady {
  color: red;
  font-weight: bold;
  animation: blink 1s infinite;
  visibility: hidden;
}
@keyframes blink {
  0%{opacity:1;}
  50%{opacity:0;}
  100%{opacity:1;}
}
#startScreen,#gameOver {
  position: fixed; top:0;left:0;right:0;bottom:0;
  background:#000;
  display:flex;align-items:center;justify-content:center;flex-direction:column;
  z-index:10;
}
#startScreen button,#gameOver button {
  font-size:22px;
  padding:12px 30px;
  border:none;
  border-radius:8px;
  background:#fff;
  color:#000;
  cursor:pointer;
}
#next {margin-top:10px;}
</style>
</head>
<body>

<div id="startScreen">
  <h1 style="font-size:40px;">Tetris Bright</h1>
  <button id="startBtn">Play!</button>
</div>

<div id="gameOver" style="display:none;">
  <h1 style="font-size:36px;">Game Over</h1>
  <button id="restartBtn">Play Again</button>
</div>

<canvas id="tetris" width="240" height="400"></canvas>

<div id="ui">
  <h1>Stats</h1>
  <p>Score: <span id="score">0</span></p>
  <p>Level: <span id="level">1</span></p>
  <p>Bonus: <span id="bonus">0</span></p>
  <p>Bombs: <span id="bombs">0</span></p>
  <p id="bombReady">Bomb Ready!</p>
  <p style="font-size:13px;color:#ccc;">Controls:<br>
  ← → Move<br>↑ Rotate<br>↓ Soft Drop<br>Space Hard Drop<br>P Pause<br>B Use Bomb</p>
  <p>Next:</p>
  <canvas id="next" width="80" height="80"></canvas>
</div>

<script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
context.scale(20,20);
const nextCanvas=document.getElementById('next');
const nextCtx=nextCanvas.getContext('2d');
nextCtx.scale(20,20);

const colors=[null,'#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#ffa500','#ff4444']; // 8=bomb red

const arena=createMatrix(12,20);
const player={pos:{x:0,y:0},matrix:null,next:null,score:0,level:1,bonus:0,bombs:0,isBomb:false};

let running=false,paused=false,lastTime=0,dropCounter=0,dropInterval=1000;

function createMatrix(w,h){const m=[];while(h--)m.push(new Array(w).fill(0));return m;}
function createPiece(t){
  switch(t){
    case 'T':return[[0,1,0],[1,1,1],[0,0,0]];
    case 'O':return[[2,2],[2,2]];
    case 'L':return[[0,3,0],[0,3,0],[0,3,3]];
    case 'J':return[[0,4,0],[0,4,0],[4,4,0]];
    case 'I':return[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
    case 'S':return[[0,6,6],[6,6,0],[0,0,0]];
    case 'Z':return[[7,7,0],[0,7,7],[0,0,0]];
  }
}
function drawMatrix(matrix,offset,ctx=context){
  matrix.forEach((row,y)=>row.forEach((val,x)=>{
    if(val!==0){
      if(val===8){
        ctx.beginPath();
        ctx.fillStyle='#ff2222';
        ctx.arc(x+offset.x+0.5,y+offset.y+0.5,0.45,0,Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle=colors[val];
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
      }
    }
  }));
}
function draw(){
  context.fillStyle='#000';
  context.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
  nextCtx.fillStyle='#000';
  nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  drawMatrix(player.next,{x:1,y:1},nextCtx);
}
function collide(arena,player){
  const[m,o]=[player.matrix,player.pos];
  for(let y=0;y<m.length;y++)
    for(let x=0;x<m[y].length;x++)
      if(m[y][x]!==0&&(arena[y+o.y]&&arena[y+o.y][x+o.x])!==0)return true;
  return false;
}
function merge(arena,player){
  player.matrix.forEach((r,y)=>r.forEach((v,x)=>{
    if(v!==0)arena[y+player.pos.y][x+player.pos.x]=v;
  }));
}
function rotate(matrix,dir){
  for(let y=0;y<matrix.length;y++)
    for(let x=0;x<y;x++)
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
  if(dir>0)matrix.forEach(r=>r.reverse());else matrix.reverse();
}
function playerMove(dir){player.pos.x+=dir;if(collide(arena,player))player.pos.x-=dir;}
function dropDown(){while(!collide(arena,player))player.pos.y++;player.pos.y--;playerDrop();}
function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    if(player.isBomb)explode(player.pos);
    else{merge(arena,player);arenaSweep();}
    playerReset();
  }
  dropCounter=0;
}
function arenaSweep(){
  let lines=0;
  outer:for(let y=arena.length-1;y>=0;--y){
    for(let x=0;x<arena[y].length;x++)if(arena[y][x]===0)continue outer;
    arena.splice(y,1);arena.unshift(new Array(arena[0].length).fill(0));++y;lines++;
  }
  if(lines>0){
    player.score+=lines*10;
    if(lines>=2){
      player.bonus+=lines===2?1:(lines===3?3:6);
      if(player.bonus>=10){player.bonus-=10;player.bombs++;}
    }
  }
}
function explode(pos){
  flashArea(pos,2);
  let cleared=0;
  for(let y=-1;y<=1;y++)
    for(let x=-1;x<=1;x++){
      const Y=pos.y+y,X=pos.x+x;
      if(arena[Y]&&arena[Y][X]>0){arena[Y][X]=0;cleared++;}
    }
  player.score+=cleared;
}
function flashArea(pos,r){
  context.fillStyle='rgba(255,255,255,0.6)';
  context.fillRect((pos.x-r)*20,(pos.y-r)*20,(r*2+1)*20,(r*2+1)*20);
  setTimeout(draw,200);
}
function playerReset(){
  player.isBomb=false;
  player.matrix=player.next;
  player.next=createPiece(pieces[(pieces.length*Math.random())|0]);
  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
  if(collide(arena,player)){
    arena.forEach(r=>r.fill(0));
    document.getElementById('gameOver').style.display='flex';
    running=false;
  }
}
function update(time=0){
  if(!running||paused)return;
  const delta=time-lastTime;lastTime=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval)playerDrop();
  draw();updateScore();
  requestAnimationFrame(update);
}
function updateScore(){
  document.getElementById('score').innerText=player.score;
  document.getElementById('level').innerText=player.level;
  document.getElementById('bonus').innerText=player.bonus;
  document.getElementById('bombs').innerText=player.bombs;
  document.getElementById('bombReady').style.visibility=player.bombs>0?'visible':'hidden';
}
document.addEventListener('keydown',e=>{
  if(!running)return;
  if(e.key==='ArrowLeft')playerMove(-1);
  else if(e.key==='ArrowRight')playerMove(1);
  else if(e.key==='ArrowDown')playerDrop();
  else if(e.key==='ArrowUp')playerRotate(1);
  else if(e.key===' ')dropDown();
  else if(e.key.toLowerCase()==='p'){
    paused=!paused;
    if(!paused){lastTime=performance.now();requestAnimationFrame(update);}
  } else if(e.key.toLowerCase()==='b'&&player.bombs>0&&!player.isBomb){
    player.isBomb=true;player.bombs--;player.matrix=[[8]];player.pos={x:5,y:0};
  }
});
function playerRotate(dir){rotate(player.matrix,dir);if(collide(arena,player))rotate(player.matrix,-dir);}
const pieces='ILJOTSZ'.split('');
function startGame(){
  document.getElementById('startScreen').style.display='none';
  document.getElementById('gameOver').style.display='none';
  arena.forEach(r=>r.fill(0));
  Object.assign(player,{score:0,level:1,bonus:0,bombs:0});
  player.next=createPiece(pieces[Math.random()*pieces.length|0]);
  playerReset();
  running=true;paused=false;lastTime=0;
  requestAnimationFrame(update);
}
document.getElementById('startBtn').onclick=startGame;
document.getElementById('restartBtn').onclick=startGame;
setInterval(()=>{
  const lv=Math.floor(player.score/100)+1;
  if(lv>player.level){player.level=lv;dropInterval=Math.max(200,1000-lv*80);}
  updateScore();
},300);
updateScore();
</script>
</body>
</html>
